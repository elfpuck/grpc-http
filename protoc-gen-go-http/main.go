package main

import (
	"bytes"
	"flag"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"html/template"
	"path"
	"time"
)

var (
	versionFlag = flag.Bool("version", false, "print the current version")
)

const (
	version  = "1.0.0"
	toolName = "protoc-gen-go-http"
)

func main() {
	flag.Parse()
	if *versionFlag {
		fmt.Printf("%v %v\n", toolName, version)
	}
	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".http.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}

	g.P("// \tCode generated by ", toolName, ". DO NOT EDIT. ")
	g.P("// \tAddress ", "https://github.com/elfpuck/grpc-http/protoc-gen-go-http")
	g.P("// \t")
	g.P("// \tversion: ")
	g.P("// \tprotoc-gen-go-http ", version)
	g.P("// \tprotoc             ", protocVersion)
	g.P("// \tcreated            ", time.Now().Format("2006-01-02 15:04:05"))
	g.P("// \tsource             ", file.Proto.GetName())
	g.P()
	g.P("package ", file.GoPackageName)

	generateFileContent(file, g)
	return g
}

func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) {
	for _, pkgPath := range []string{
		"github.com/elfpuck/grpc-http/elfHttp",
		"google.golang.org/grpc",
	} {
		g.QualifiedGoIdent(protogen.GoIdent{GoName: path.Base(pkgPath), GoImportPath: protogen.GoImportPath(pkgPath)})
	}

	data := PackageData{
		AngleBracket: template.HTML("<"),
		Services:     make([]*ServiceData, 0, len(file.Services)),
	}
	for _, service := range file.Services {
		methodArr := make([]*MethodData, 0, len(service.Methods))
		for _, method := range service.Methods {
			methodArr = append(methodArr, &MethodData{
				Name:   method.GoName,
				Input:  method.Input.GoIdent.GoName,
				Output: method.Output.GoIdent.GoName,
			})
		}
		data.Services = append(data.Services, &ServiceData{
			Name:    service.GoName,
			Methods: methodArr,
		})
	}
	g.P(executeTemplate(&data))
}

type PackageData struct {
	AngleBracket template.HTML
	Services     []*ServiceData
}
type ServiceData struct {
	Name    string
	Methods []*MethodData
}
type MethodData struct {
	Name        string
	NameToLower string
	Input       string
	Output      string
}

func executeTemplate(data *PackageData) string {
	t := template.Must(template.New("http.pb.go").Parse(TEMPLATE))
	res := new(bytes.Buffer)
	if err := t.Execute(res, data); err != nil {
		panic(err)
	}
	return res.String()
}
