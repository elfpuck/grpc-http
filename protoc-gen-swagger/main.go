package main

import (
	"bytes"
	"flag"
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"html/template"
	"path"
	"strings"
	"time"
)

var (
	versionFlag = flag.Bool("version", false, "print the current version")
)

const (
	version  = "1.0.0"
	toolName = "protoc-gen-swagger"
)

func main() {
	flag.Parse()
	if *versionFlag {
		fmt.Printf("%v %v\n", toolName, version)
	}
	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + ".swagger.yaml"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
	}
	g.P("# \tYaml generated by ", toolName, ".")
	g.P("# \tAddress ", "https://github.com/elfpuck/grpc-http/protoc-gen-swagger")
	g.P("# \t")
	g.P("# \tversion: ")
	g.P("# \tprotoc-gen-go-http ", version)
	g.P("# \tprotoc             ", protocVersion)
	g.P("# \tcreated            ", time.Now().Format("2006-01-02 15:04:05"))
	g.P("# \tsource             ", file.Proto.GetName())
	g.P()

	generateFileContent(file, g)
	return g
}

func generateFileContent(file *protogen.File, g *protogen.GeneratedFile) {
	data := PackageData{
		SourceName: file.Proto.GetName(),
		ApiArr:     make([]*apiStruct, 0, 20),
		SchemaArr:  make([]*schemaStruct, 0, 40),
	}
	for _, service := range file.Services {
		for _, method := range service.Methods {
			schemaReq := schemaStruct{
				Comments: currentStr(method.Input.Comments.Leading.String(), method.Input.Comments.Trailing.String()),
				Name:     fmt.Sprintf("%v%s", file.GoPackageName, method.Input.GoIdent.GoName),
			}
			schemaRes := schemaStruct{
				Comments: currentStr(method.Output.Comments.Leading.String(), method.Output.Comments.Trailing.String()),
				Name:     fmt.Sprintf("%v%s", file.GoPackageName, method.Output.GoIdent.GoName),
				Params: []*schemaParamsStruct{
					{
						ParamsName: "Code",
						ParamsType: "integer",
					},
					{
						ParamsType: "string",
						ParamsName: "Message",
					},
				},
			}
			api := apiStruct{
				Summary:   method.Comments.Leading.String(),
				RoutePath: path.Join("/", fmt.Sprintf("%v", file.GoPackageName), method.GoName),
				SchemaReq: schemaReq.Name,
				SchemaRes: schemaRes.Name,
				Tag:       service.GoName,
			}

			// 请求参数
			for _, v := range method.Input.Fields {
				schemaParamsStruct := schemaParamsStruct{
					Comments:   currentStr(v.Comments.Leading.String(), v.Comments.Trailing.String()),
					ParamsName: v.Desc.JSONName(),
					ParamsType: switchType(v.Desc.Kind().String()),
				}
				schemaReq.Params = append(schemaReq.Params, &schemaParamsStruct)
			}

			//返回参数
			resSchema := schemaParamsStruct{
				ParamsName: "Data",
				ParamsType: "object",
			}

			for _, v := range method.Output.Fields {
				schema := schemaParamsStruct{
					Comments:   currentStr(v.Comments.Leading.String(), v.Comments.Trailing.String()),
					ParamsName: v.Desc.JSONName(),
					ParamsType: switchType(v.Desc.Kind().String()),
				}
				resSchema.SonParams = append(resSchema.SonParams, &schema)
			}

			schemaRes.Params = append(schemaRes.Params, &resSchema)

			data.SchemaArr = append(data.SchemaArr, &schemaReq, &schemaRes)
			data.ApiArr = append(data.ApiArr, &api)
		}
	}
	g.P(executeTemplate(&data))
}

func executeTemplate(data *PackageData) string {
	t := template.Must(template.New("swagger.yaml").Parse(TEMPLATE))
	res := new(bytes.Buffer)
	if err := t.Execute(res, data); err != nil {
		panic(err)
	}
	return res.String()
}

func currentStr(str ...string) string {
	for _, v := range str {
		if v != "" {
			return strings.Replace(v, "\n", "\t", -1)
		}
	}
	return ""
}

func switchType(str string) string {
	switch str {
	case "message":
		return "object"
	case "int32", "uint32", "int64", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64":
		return "integer"
	case "double", "float":
		return "number"
	case "bytes":
		return "string"
	default:
		return str
	}
	return str
}

type PackageData struct {
	SourceName string
	ApiArr     []*apiStruct
	SchemaArr  []*schemaStruct
}

type apiStruct struct {
	Summary   string
	RoutePath string
	SchemaReq string
	SchemaRes string
	Tag       string
}

type schemaStruct struct {
	Comments string
	Name     string
	Params   []*schemaParamsStruct
}

type schemaParamsStruct struct {
	Comments   string
	ParamsName string
	ParamsType string
	SonParams  []*schemaParamsStruct
}
